#!/usr/bin/env bash
# Copyright (C) 2026 Advanced Micro Devices, Inc. All rights reserved.
# Licensed under the MIT License.
#
# Package the installed LLVM/MLIR/LLD into a zip file and upload to GitHub Releases.
# File staging is driven by install_manifest.txt generated by CMake, so the zip
# exactly matches what was installed â€” no hardcoded filename patterns.
#
# Usage:
#   bash scripts/package-and-upload.sh [--name <pkg>] [--version <tag>] [--build-dir <path>] [--install-dir <path>] [--dry-run]
#
# Examples:
#   bash scripts/package-and-upload.sh --version llvm-22.1.0-release
#   bash scripts/package-and-upload.sh --name protobuf --version protobuf-34.0-release
#   bash scripts/package-and-upload.sh --version llvm-22.1.0-release --dry-run
#
# Prerequisites:
#   - gh CLI authenticated (gh auth login)
#   - 7z or zip available
#   - Enough disk space for zip files

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# --- Defaults (derived from repo root, no hardcoded paths) ---
NAME=""        # package name prefix, e.g. "llvm-mlir-lld" or "protobuf"
VERSION=""
BUILD_DIR=""   # default: derived from NAME
INSTALL_DIR="" # default: derived from NAME
DRY_RUN=false
REPO="wcy123/llvm-mlir-prebuilt"
PART_SIZE_MB=1800  # Keep each zip under 2GB GitHub limit

# --- Arg parsing ---
while [[ $# -gt 0 ]]; do
    case "$1" in
        --name)        NAME="$2";        shift 2 ;;
        --version)     VERSION="$2";     shift 2 ;;
        --build-dir)   BUILD_DIR="$2";   shift 2 ;;
        --install-dir) INSTALL_DIR="$2"; shift 2 ;;
        --dry-run)     DRY_RUN=true;     shift ;;
        *) echo "Unknown arg: $1"; exit 1 ;;
    esac
done

if [ -z "$VERSION" ]; then
    echo "ERROR: --version is required. Example: --version llvm-22.1.0-release"
    exit 1
fi

# Default name, build-dir, and install-dir based on package
if [ -z "$NAME" ]; then
    NAME="llvm-mlir-lld"
fi
if [ -z "$BUILD_DIR" ]; then
    case "$NAME" in
        protobuf) BUILD_DIR="$REPO_ROOT/.workspace/build/protobuf-release" ;;
        *)        BUILD_DIR="$REPO_ROOT/.workspace/build/llvm-project-release" ;;
    esac
fi
if [ -z "$INSTALL_DIR" ]; then
    case "$NAME" in
        protobuf) INSTALL_DIR="$REPO_ROOT/.workspace/local-protobuf" ;;
        *)        INSTALL_DIR="$REPO_ROOT/.workspace/local" ;;
    esac
fi

MANIFEST="$BUILD_DIR/install_manifest.txt"

if [ ! -f "$MANIFEST" ]; then
    echo "ERROR: install_manifest.txt not found: $MANIFEST"
    echo "       Run build-llvm.sh first, or pass --build-dir <path>"
    exit 1
fi

WORK_DIR="$REPO_ROOT/.workspace/llvm-pkg-$$"
mkdir -p "$WORK_DIR"
trap "rm -rf $WORK_DIR" EXIT

echo "=== Package and Upload ==="
echo "Name:        $NAME"
echo "Manifest:    $MANIFEST"
echo "Install dir: $INSTALL_DIR"
echo "Version tag: $VERSION"
echo "Repo:        $REPO"
echo "Work dir:    $WORK_DIR"
echo "Dry run:     $DRY_RUN"
echo ""

# --- Stage all files from install_manifest.txt into a single directory ---
STAGE="$WORK_DIR/stage"
mkdir -p "$STAGE"

echo "=== Staging files from install_manifest.txt ==="

while IFS= read -r abs_path; do
    # Strip carriage return (manifest may have Windows CRLF line endings)
    abs_path="${abs_path%$'\r'}"
    # Normalize to forward slashes
    abs_path="${abs_path//\\//}"
    install_norm="${INSTALL_DIR//\\//}"

    # Normalize drive letter: /c/... -> C:/... so both sides match
    abs_norm="$abs_path"
    if [[ "$abs_norm" =~ ^/([a-zA-Z])/(.*) ]]; then
        abs_norm="${BASH_REMATCH[1]^}:/${BASH_REMATCH[2]}"
    fi
    if [[ "$install_norm" =~ ^/([a-zA-Z])/(.*) ]]; then
        install_norm="${BASH_REMATCH[1]^}:/${BASH_REMATCH[2]}"
    fi

    # Strip install dir prefix to get relative path
    rel="${abs_norm#$install_norm/}"
    if [ "$rel" = "$abs_norm" ]; then
        echo "  WARNING: not under INSTALL_DIR, skipping: $abs_path"
        continue
    fi

    dest="$STAGE/$rel"
    mkdir -p "$(dirname "$dest")"
    cp "$abs_path" "$dest"
done < "$MANIFEST"

# --- Package ---
echo ""
echo "=== Creating zip file ==="
ZIP_OUT="$WORK_DIR/zips"
mkdir -p "$ZIP_OUT"

NAME="llvm-mlir-lld"
PLATFORM="windows-x64"
TMP_ZIP="$WORK_DIR/${NAME}-full.zip"

if command -v 7z &>/dev/null; then
    7z a -tzip -mx=1 "$(cygpath -w "$TMP_ZIP")" "$(cygpath -w "$STAGE")/*" -r > /dev/null
else
    (cd "$STAGE" && zip -r -1 -q "$TMP_ZIP" .)
fi

SIZE_MB=$(du -m "$TMP_ZIP" | cut -f1)
echo "  Full zip: ${SIZE_MB}MB"

if [ "$SIZE_MB" -le "$PART_SIZE_MB" ]; then
    OUT="$ZIP_OUT/${NAME}-${VERSION}-${PLATFORM}.zip"
    mv "$TMP_ZIP" "$OUT"
    echo "  Output: $OUT"
else
    echo "  Splitting into ${PART_SIZE_MB}MB parts..."
    part=1
    if command -v 7z &>/dev/null; then
        7z a -tzip -mx=1 -v${PART_SIZE_MB}m \
           "$(cygpath -w "$WORK_DIR/${NAME}-split.zip")" "$(cygpath -w "$STAGE")/*" -r > /dev/null
        for f in "$WORK_DIR"/${NAME}-split.zip.*; do
            out="$ZIP_OUT/${NAME}-${VERSION}-${PLATFORM}-part$(printf '%02d' $part).zip"
            mv "$f" "$out"
            echo "  Part $part: $out ($(du -m "$out" | cut -f1)MB)"
            ((part++))
        done
    else
        split -b ${PART_SIZE_MB}m "$TMP_ZIP" "$ZIP_OUT/${NAME}-${VERSION}-${PLATFORM}-part"
        for f in "$ZIP_OUT"/${NAME}-${VERSION}-${PLATFORM}-part*; do
            mv "$f" "${f}.zip"
            echo "  Part: ${f}.zip ($(du -m "${f}.zip" | cut -f1)MB)"
        done
        rm "$TMP_ZIP"
    fi
fi

echo ""
echo "=== Generated files ==="
ls -lh "$ZIP_OUT"

# --- Upload ---
if [ "$DRY_RUN" = true ]; then
    echo ""
    echo "=== Dry run: skipping upload ==="
    echo "Would upload to: https://github.com/$REPO/releases/tag/$VERSION"
    exit 0
fi

echo ""
echo "=== Creating GitHub release $VERSION ==="
gh release create "$VERSION" \
    --repo "$REPO" \
    --title "LLVM/MLIR/LLD $VERSION" \
    --notes "Prebuilt LLVM+MLIR+LLD for Windows x64. See README for build config." \
    2>/dev/null || echo "Release $VERSION already exists, uploading to existing release."

echo ""
echo "=== Uploading zip files ==="
for f in "$ZIP_OUT"/*.zip; do
    echo "Uploading $(basename "$f") ($(du -h "$f" | cut -f1))..."
    gh release upload "$VERSION" "$f" \
        --repo "$REPO" \
        --clobber
done

echo ""
echo "=== Done ==="
echo "Release: https://github.com/$REPO/releases/tag/$VERSION"
